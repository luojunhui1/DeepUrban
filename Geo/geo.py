import folium
import math
import numpy as np
import sys, os
sys.path.append(os.path.dirname(__file__) + os.sep + '../')
from Utils.utils import rgb2hex

def get_polygons(clat=39.922353, clon=116.391958, grid_h=32, grid_w=32, acc=1000):
    """
    divide square area as 'grid_h' * 'grid_w' grid map

    Paramters
    -----
    clat : float
        center latitude
    clon : float
        center longitude
    grid_h : integer
        rows of gird map   
    grid_w : integer
        colunms of gird map 
    acc : integer
        accuracy, unit is 'meter'
    
    Returns
    -----
    polygons : list, shape: 'grid_h'*'grid_w'*4
        ploygons generated from top to bottom and left to right, the order of vertical is 
        'upper left', 'upper right', 'lower right', 'lower left'
    """
    polar_radius = 6356908.8  # 地球极半径
    lat_perimeter = 2 * math.pi * 1000 / math.sqrt(
        1 / (6377.830 ** 2) + (math.tan(math.radians(clat)) / 6377.830) ** 2)  # 区域所在纬半径

    lon_delta = 360 * acc / lat_perimeter  # 经度划分精度
    lat_delta = 360 * acc / (polar_radius * math.pi * 2)  # 纬度划分精度

    lats = np.linspace(clat + grid_h/2.0 * lat_delta, clat - grid_h/2.0 * lat_delta, grid_h + 1)
    lons = np.linspace(clon - grid_w/2.0 * lon_delta, clon + grid_w/2.0 * lon_delta, grid_w + 1)

    polygons = []

    for i in range(0, grid_h):
        for j in range(0, grid_w):
            polygons.append([
                [lats[i], lons[j]],
                [lats[i], lons[j + 1]],
                [lats[i + 1], lons[j + 1]],
                [lats[i + 1], lons[j]]
            ])
    return polygons

def lonlat2index(clat=39.922353, clon=116.391958, grid_h=32, grid_w=32, acc=1000, loc = []):
    """
    transfrom longitude and latitude coordinates to grid map index
    
    Parameters
    -----
    clat : float
        center latitude
    clon : float
        center longitude
    grid_h : integer
        rows of gird map 
    grid_w : integer
        colunms of gird map
    acc : integer
        accuracy, unit is 'meter'
    loc : list or array-like
        longitude and latitude coordinates list

    Returns
    -----
    two lists or arrays corresponding to row-index and col-index
    """
    polar_radius = 6356908.8  # 地球极半径
    lat_perimeter = 2 * math.pi * 1000 / math.sqrt(
        1 / (6377.830 ** 2) + (math.tan(math.radians(clat)) / 6377.830) ** 2)  # 区域所在纬半径

    lon_delta = 360 * acc / lat_perimeter  # 经度划分精度
    lat_delta = 360 * acc / (polar_radius * math.pi * 2)  # 纬度划分精度

    return grid_h/2 - (loc[1,:] - clat)//lat_delta, grid_w/2 + (loc[0,:] - clon)//lon_delta

def get_map(clat=39.922353, clon=116.391958, polygons=None, colors=None, show=False, opacity = 0.7, save=False):
    """
    get an 'Folium Map Object' generated by parameters, mainly used for drawinf polygons on map
    
    Parameters
    -----
    clat : float
        center latitude
    clon : float
        center longitude
    polygons : list or array-like
        ploygons needed to be draw
    colors : list or array-like
        color correspoding to each ploygon
    show : Boolean
        return an 'Folium Map Object' or not
    opacity : 
        opacity of color
    save : Boolean
        save a map html or not, default file name is 'map.html'

    Returns
    -----
     it depends, a 'Folium Map Object' or none
    
    """
    cur_map = folium.Map(location=[clat, clon], zoom_start=12, tiles='CartoDB positron', png_enabled=False)

    index = 0
    for grid in list(polygons):
        _curr_ = folium.Polygon(
            locations=grid,
            color='white',
            weight=1,
            fill_color=colors[index] if isinstance(colors[index], str) else rgb2hex(colors[index]),
            fill_opacity=opacity,
            fill=True,
        )
        _curr_.add_to(cur_map)
        index = index + 1

    if save:
        cur_map.save('./map.html')
    if show:
        return cur_map

    return None

def adjacency_regions(loc, grid_h, grid_w):
    """
    get the adjacency region indexs of region 'loc' 
    
    Parameters
    -----
    loc : integer
        region index
    grid_h:
        rows of grid map
    grid_w:
        cols of grid map

    Returns
    -----
    list, the adjacency region indexs of region 'loc' 
    """
    nearAreaIncres = [ [-1, 0], [1, 0], [0, -1], [0, 1]]
    res = []
    for i in range(0, len(nearAreaIncres)):
        if (loc < grid_w and i == 0) or \
            (loc >= (grid_w*(grid_h - 1)) and i == 1) or \
            (loc%grid_w == 0 and i == 2) or\
            (loc%(grid_w - 1) == 0 and loc > 0 and i == 3):
            continue
        res.append(loc + nearAreaIncres[i][0]*grid_w + nearAreaIncres[i][1])
    return res

def refine_labels(labels, data=None, grid_h = 16, grid_w = 16, centers=None, sse_means=None, sse_stds=None, strong = True):
    """
    refine the region labels according to the region's spatial relations
    
    Parameters
    -----
    labels : array-like
        labels of regions    
    data : array-like, shape: (region num, region features)
        data of regions  
    grid_h : integer
        rows of grid map
    grid_w : integer
        cols of grid map
    centers : array-like, shape: (region num, region features)
        label centers of every region
    sse_means : array-like, shape: (region num, region features)
        label's sse means of every region
    sse_stds : array-like, shape: (region num, region features)
        label's sse stds of every region    

    Returns
    -----
    refined labels
    
    """
    region_num = grid_h*grid_w

    for i in range(0, region_num):
        adj_regions = adjacency_regions(i, grid_h, grid_w)
        if labels[i] in labels[adj_regions]:
            continue
        else:
            min_dis = np.inf
            min_dis_class = labels[i]
            for region in adj_regions:
                cur_dis = np.sum((data[i] - centers[region])**2)
                if cur_dis < min_dis:
                    if strong:
                        if abs(cur_dis - sse_means[region]) < 3 * sse_stds[region]:
                            min_dis_class = labels[region]
                            min_dis = cur_dis
                    else:
                        min_dis_class = labels[region]
                        min_dis = cur_dis
            labels[i] = min_dis_class
    return labels